//opencv
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include <opencv2/highgui.hpp>
#include <opencv2/video.hpp>
//C
#include <stdio.h>
//C++
#include <iostream>
#include <sstream>


using namespace cv;
using namespace std;

// Global variables
Mat frame; //current frame
Mat fg_mask_mog_2; //fg mask fg mask generated by MOG2 method
Mat fg_mask_sum;
bool fg_mask_sum_initialized = false;
Mat fg_mask_sum_normalized;
Mat fg_mask_sum_colored;
Ptr<BackgroundSubtractor> mog_2_ptr; //MOG2 Background subtractor
int keyboard; //input from keyboard

void help();

void processImage(Mat frame);

void processVideo(char* video_filename);

void processImages(char* first_frame_filename);

void processRawVideo(char* video_filename);

void help()
{
  cout
    << "---------------------------------------------------------------------------"  << endl
    << "This program shows how to use background subtraction methods provided by   "  << endl
    << " OpenCV. You can process videos (-vid), images (-img), and raw files (-raw)." << endl
    << endl
    << "Usage:"                                                                       << endl
    << "./analyze {-vid <video filename>|-img <image filename>}"                      << endl
    << "for example: ./analyze -vid video.avi"                                        << endl
    << "or: ./analyze -img /data/images/1.png"                                        << endl
    << "or: ./analyze -raw video.raw"                                                 << endl
    << "--------------------------------------------------------------------------"   << endl
    << endl;
}

int main(int argc, char* argv[])
{
  //print help information
  help();

  //create GUI windows
  // namedWindow("Frame");
  // namedWindow("FG Mask MOG 2");
  // namedWindow("fg_mask_sum");

  //create Background Subtractor objects
  mog_2_ptr = createBackgroundSubtractorMOG2(); //MOG2 approach
  if(strcmp(argv[1], "-vid") == 0)
  {
    //check for the input parameter correctness
    if(argc != 3)
    {
      cerr <<"Incorret input list" << endl;
      cerr <<"exiting..." << endl;
      return EXIT_FAILURE;
    }

    //input data coming from a video
    processVideo(argv[2]);
  }
  else if(strcmp(argv[1], "-img") == 0)
  {
    //check for the input parameter correctness
    if(argc != 3)
    {
      cerr <<"Incorret input list" << endl;
      cerr <<"exiting..." << endl;
      return EXIT_FAILURE;
    }

    //input data coming from a sequence of images
    processImages(argv[2]);
  }
  else if(strcmp(argv[1], "-raw") == 0)
  {
    //check for the input parameter correctness
    if(argc != 3)
    {
      cerr <<"Incorret input list" << endl;
      cerr <<"exiting..." << endl;
      return EXIT_FAILURE;
    }

    //input data coming from a sequence of images
    processRawVideo(argv[2]);
  }
  else
  {
    //error in reading input parameters
    cerr <<"Please, check the input parameters." << endl;
    cerr <<"Exiting..." << endl;
    return EXIT_FAILURE;
  }

  //destroy GUI windows
  destroyAllWindows();

  return EXIT_SUCCESS;
}

void processImage(Mat frame)
{
  //show the current frame and the fg masks
  // imshow("Frame", frame);

  // imshow("FG Mask MOG 2", fg_mask_mog_2);

  //update the background model
  mog_2_ptr->apply(frame, fg_mask_mog_2);

  if (fg_mask_sum_initialized)
  {
    add(fg_mask_sum,fg_mask_mog_2,fg_mask_sum,noArray(),CV_64F);
  }
  else
  {
    fg_mask_sum = fg_mask_mog_2;
    fg_mask_sum.convertTo(fg_mask_sum,CV_64F);
    fg_mask_sum_initialized = true;
  }
  //get the frame number and write it on the current frame
  // stringstream ss;
  // rectangle(frame, cv::Point(10, 2), cv::Point(100,20),
  //           cv::Scalar(255,255,255), -1);
  // ss << capture.get(CAP_PROP_POS_FRAMES);
  // string frameNumberString = ss.str();
  // putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
  //         FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));
  //show the current frame and the fg masks
  // imshow("Frame", frame);
  // imshow("FG Mask MOG 2", fg_mask_mog_2);
  normalize(fg_mask_sum,fg_mask_sum_normalized,0,255,NORM_MINMAX,CV_8U);
  applyColorMap(fg_mask_sum_normalized,fg_mask_sum_colored,COLORMAP_JET);

  //get the input from the keyboard
  // keyboard = waitKey(1);
}

void processVideo(char* video_filename)
{
  //create the capture object
  VideoCapture capture(video_filename);
  if(!capture.isOpened())
  {
    //error in opening the video input
    cerr << "Unable to open video file: " << video_filename << endl;
    exit(EXIT_FAILURE);
  }

  int i = 0;
  //read input data. ESC or 'q' for quitting
  while( (char)keyboard != 'q' && (char)keyboard != 27 && i++ < 10000)
  {
    //read the current frame
    if(!capture.read(frame))
    {
      cerr << "Unable to read next frame." << endl;
      cerr << "Exiting..." << endl;
      exit(EXIT_FAILURE);
    }
    processImage(frame);

    imshow("fg_mask_sum", fg_mask_sum_colored);

    //get the input from the keyboard
    keyboard = waitKey( 1 );
  }

  imwrite("sum.png",fg_mask_sum_colored);

  //delete capture object
  capture.release();
}

void processImages(char* first_frame_filename)
{
  // //read the first file of the sequence
  // frame = imread(first_frame_filename);
  // if(frame.empty())
  // {
  //   //error in opening the first image
  //   cerr << "Unable to open first image frame: " << first_frame_filename << endl;
  //   exit(EXIT_FAILURE);
  // }

  // //current image filename
  // string fn(first_frame_filename);

  // //read input data. ESC or 'q' for quitting
  // while( (char)keyboard != 'q' && (char)keyboard != 27 )
  // {
  //   //update the background model
  //   mog_2_ptr->apply(frame, fg_mask_mog_2);
  //   //get the frame number and write it on the current frame
  //   size_t index = fn.find_last_of("/");
  //   if(index == string::npos)
  //   {
  //     index = fn.find_last_of("\\");
  //   }
  //   size_t index2 = fn.find_last_of(".");
  //   string prefix = fn.substr(0,index+1);
  //   string suffix = fn.substr(index2);
  //   string frameNumberString = fn.substr(index+1, index2-index-1);
  //   istringstream iss(frameNumberString);
  //   int frameNumber = 0;
  //   iss >> frameNumber;
  //   rectangle(frame, cv::Point(10, 2), cv::Point(100,20),
  //             cv::Scalar(255,255,255), -1);
  //   putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
  //           FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));

  //   //show the current frame and the fg masks
  //   imshow("Frame", frame);
  //   imshow("FG Mask MOG 2", fg_mask_mog_2);

  //   //get the input from the keyboard
  //   keyboard = waitKey( 30 );

  //   //search for the next image in the sequence
  //   ostringstream oss;
  //   oss << (frameNumber + 1);
  //   string nextFrameNumberString = oss.str();
  //   string nextFrameFilename = prefix + nextFrameNumberString + suffix;

  //   //read the next frame
  //   frame = imread(nextFrameFilename);
  //   if(frame.empty())
  //   {
  //     //error in opening the next image in the sequence
  //     cerr << "Unable to open image frame: " << nextFrameFilename << endl;
  //     exit(EXIT_FAILURE);
  //   }

  //   //update the path of the current frame
  //   fn.assign(nextFrameFilename);
  // }
}

void processRawVideo(char* video_filename)
{
  int IMAGE_WIDTH = 1920;
  int IMAGE_HEIGHT = 1200;
  Mat img;
  FILE * fp = NULL;
  unsigned char * imagedata = NULL;
  int framesize = IMAGE_WIDTH * IMAGE_HEIGHT;
  int framecount = 1000;

  //Open raw Bayer image.
  fp = fopen(video_filename, "rb");

  //Memory allocation for bayer image data buffer.
  imagedata = (unsigned char *) malloc (sizeof(unsigned char) * framesize);

  for (int frame_n=0; frame_n<framecount; ++frame_n)
  {
    //Read image data and store in buffer.
    fread(imagedata, sizeof(unsigned char), framesize, fp);

    //Image dimension.
    // imageSize.height = IMAGE_WIDTH;
    // imageSize.width = IMAGE_HEIGHT;

    //Create Opencv mat structure for image dimension. For 8 bit bayer, type should be CV_8UC1.
    img.create(IMAGE_HEIGHT, IMAGE_WIDTH, CV_8UC1);

    memcpy(img.data, imagedata, framesize);

    processImage(img);
  }

  free(imagedata);

  fclose(fp);

  imshow("fg_mask_sum", fg_mask_sum_colored);

  imwrite("sum.png",fg_mask_sum_colored);

  //get the input from the keyboard
  keyboard = waitKey(0);

    //Perform demosaicing process
  // cvtColor(img, RGBImage, CV_BayerBG2BGR);


  // ifstream file_stream(video_filename);
  // if (!file_stream)
  // {
  //   //error in opening the video input
  //   cerr << "Unable to open raw video file: " << video_filename << endl;
  //   exit(EXIT_FAILURE);
  // }
  // unsigned char frame[1920][1200];
  // int i = 0;
  // while (fin >> ch)
  // {
  //   cout << (unsigned int)ch << " ";
  // }
  // cout << endl;
  // fin.close();
  // cin >> ch;

  // //create the capture object
  // VideoCapture capture(video_filename);
  // if(!capture.isOpened())
  // {
  //   //error in opening the video input
  //   cerr << "Unable to open video file: " << video_filename << endl;
  //   exit(EXIT_FAILURE);
  // }

  // int i = 0;
  // //read input data. ESC or 'q' for quitting
  // while( (char)keyboard != 'q' && (char)keyboard != 27 && i++ < 10000)
  // {
  //   //read the current frame
  //   if(!capture.read(frame))
  //   {
  //     cerr << "Unable to read next frame." << endl;
  //     cerr << "Exiting..." << endl;
  //     exit(EXIT_FAILURE);
  //   }
  //   //update the background model
  //   mog_2_ptr->apply(frame, fg_mask_mog_2);
  //   if (fg_mask_sum_initialized)
  //   {
  //     add(fg_mask_sum,fg_mask_mog_2,fg_mask_sum,noArray(),CV_64F);
  //   }
  //   else
  //   {
  //     fg_mask_sum = fg_mask_mog_2;
  //     fg_mask_sum.convertTo(fg_mask_sum,CV_64F);
  //     fg_mask_sum_initialized = true;
  //   }
  //   //get the frame number and write it on the current frame
  //   // stringstream ss;
  //   // rectangle(frame, cv::Point(10, 2), cv::Point(100,20),
  //   //           cv::Scalar(255,255,255), -1);
  //   // ss << capture.get(CAP_PROP_POS_FRAMES);
  //   // string frameNumberString = ss.str();
  //   // putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
  //   //         FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));
  //   //show the current frame and the fg masks
  //   // imshow("Frame", frame);
  //   // imshow("FG Mask MOG 2", fg_mask_mog_2);
  //   normalize(fg_mask_sum,fg_mask_sum_normalized,0,255,NORM_MINMAX,CV_8U);
  //   applyColorMap(fg_mask_sum_normalized,fg_mask_sum_colored,COLORMAP_JET);
  //   imshow("fg_mask_sum", fg_mask_sum_colored);
  //   //get the input from the keyboard
  //   keyboard = waitKey( 1 );
  // }

  // imwrite("sum.png",fg_mask_sum_colored);

  // //delete capture object
  // capture.release();
}
